#include "ReWire_MAX32664.h"

// calib vector sample from https://github.com/Protocentral/protocentral-pulse-express/
uint8_t calibVector[5][CALIBVECTOR_SIZE] = {
    {0x21, 0xB4, 0x34, 0x01, 0x34, 0xFC, 0x01, 0x00, 0x78, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x4A, 0xB8, 0x17, 0xDC, 0x20, 0x8C, 0xE4, 0xFD, 0x3F, 0xF4, 0x3C, 0x90, 0xAE, 0x4D, 0x75, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1B, 0x45, 0xBC, 0xFE, 0x80, 0xE4, 0x3D, 0x71, 0x8D, 0x9D, 0x3E, 0xED, 0x14, 0x07, 0x3F, 0x6D, 0x59, 0x38, 0x3F, 0x23, 0x66, 0x59, 0x3F, 0x29, 0x4B, 0x68, 0x3F, 0x14, 0xF0, 0x6B, 0x3F, 0x74, 0x27, 0x6E, 0x3F, 0x99, 0xB5, 0x72, 0x3F, 0xE8, 0xFD, 0x76, 0x3F, 0x3D, 0x1A, 0x7B, 0x7F, 0x87, 0xC3, 0x56, 0xE2, 0x30, 0xAB, 0x5A, 0x75, 0x58, 0x6F, 0xC5, 0x3A, 0xF2, 0x8E, 0x3A, 0x3F, 0x9D, 0xAC, 0x2B, 0x3F, 0xC5, 0x2C, 0x22, 0x3F, 0xE4, 0x53, 0x1D, 0x3F, 0xFE, 0xEF, 0x1B, 0x3F, 0x04, 0x20, 0x1B, 0x3F, 0xCD, 0xFC, 0x17, 0x3F, 0x57, 0x70, 0x12, 0x3F, 0x15, 0x91, 0x0B, 0x3F, 0x51, 0xA4, 0x03, 0x3F, 0xE5, 0x62, 0xFB, 0x3E, 0x30, 0xAC, 0xF2, 0x3E, 0x22, 0xDE, 0xA4, 0xA4, 0x82, 0x1B, 0x95, 0x2A, 0x70, 0x60, 0x5F, 0x54, 0x4A, 0x6C, 0x7A, 0x87, 0x4E, 0x8F, 0x9D, 0x3E, 0xBF, 0x6E, 0x8C, 0x3E, 0xEE, 0xEB, 0x82, 0x3E, 0x78, 0x4B, 0x78, 0x3E, 0x5C, 0x15, 0x70, 0x3E, 0x02, 0xF2, 0x67, 0x3E, 0xF5, 0xEF, 0x5B, 0x3E, 0xB3, 0x4F, 0x52, 0x3E, 0xD4, 0x35, 0x49, 0x3E, 0x10, 0xAB, 0x3B, 0x3E, 0x9E, 0x35, 0x27, 0x3E, 0x06, 0xAD, 0x0C, 0x3E, 0x9C, 0x32, 0x9C, 0x04, 0x11, 0xF7, 0xA3, 0x29, 0x04, 0xB2, 0xA3, 0xB1, 0xF8, 0xD9, 0x99, 0x44, 0x6A, 0x9E, 0x07, 0x3E, 0xE8, 0xC2, 0xC0, 0x3D, 0x87, 0x4A, 0x16, 0x3D, 0xE7, 0x9D, 0x00, 0x0F, 0x09, 0x4F, 0x44, 0x6D, 0x7D, 0xB4, 0x9D, 0x20, 0xBA, 0x11, 0x45, 0x9F, 0x82, 0xE1, 0x85, 0xD2, 0x77, 0x61, 0xB4, 0x4B, 0xA0, 0xE3, 0xBC, 0x72, 0x6E, 0x0A, 0xBD, 0x61, 0x38, 0x3D, 0x23, 0x0E, 0x3D, 0x1F, 0x5C, 0x2C, 0x5E, 0x7A, 0x61, 0x89, 0xD9, 0x08, 0xA9, 0x70, 0x24, 0x3E, 0x3E, 0xF8, 0xEB, 0x39, 0x63, 0x63, 0x09, 0x28, 0x3F, 0x5A, 0xFA, 0x05, 0x95, 0x48, 0x65, 0xF3, 0xB1, 0x2D, 0xC5, 0x6F, 0x57, 0x94, 0x71, 0xBB, 0x18, 0x85, 0x64, 0xE1, 0x18, 0x37, 0x6C, 0xB3, 0xCE, 0x51, 0x69, 0xF9, 0xE5, 0x92, 0x8A, 0xF2, 0x89, 0x47, 0xC9, 0x83, 0x25, 0x0E, 0x0A, 0x5E, 0x3D, 0xCC, 0x94, 0x9C, 0xA5, 0xB1, 0xF1, 0xC1, 0x1C, 0xA5, 0x09, 0xB7, 0xDA, 0xEF, 0x20, 0xF6, 0x20, 0x2E, 0x06, 0x2C, 0xDC, 0x99, 0xB5, 0xFA, 0xB9, 0x58, 0x1A, 0xEF, 0x53, 0x20, 0xBF, 0x43, 0x2F, 0x06, 0x1E, 0x19, 0xED, 0xE5, 0x31, 0x73, 0x43, 0xFC, 0x06, 0xC3, 0xE8, 0xB3, 0x7E, 0xA2, 0x24, 0xA0, 0xFC, 0x72, 0x50, 0xD5, 0xEA, 0xAD, 0x4D, 0x9E, 0xF7, 0x5F, 0x89, 0xEA, 0xE6, 0x25, 0x89, 0x84, 0xDF, 0xBD, 0xB7, 0x2E, 0xFC, 0xF7, 0x2F, 0xDE, 0x38, 0x0D, 0x78, 0x0F, 0x01, 0x2D, 0x62, 0xEF, 0x60, 0x7E, 0x52, 0x6C, 0x76, 0x08, 0x2B, 0x27, 0xA8, 0x55, 0x22, 0xC9, 0x88, 0xED, 0xAC, 0x46, 0x08, 0x46, 0x30, 0xCE, 0x15, 0xD9, 0x25, 0x2C, 0x50, 0xA7, 0x47, 0x43, 0x5D, 0xB8, 0xE4, 0x68, 0xD6, 0x14, 0xA6, 0x7F, 0x9D, 0x78, 0xA1, 0x0C, 0x2E, 0x7C, 0xC9, 0xF4, 0x2A, 0x7E, 0x1E, 0x77, 0x3A, 0x28, 0x20, 0x35, 0xE5, 0xED, 0x40, 0x9D, 0xE9, 0x2D, 0xEC, 0xEC, 0xEF, 0xDC, 0x04, 0x1C, 0x48, 0x07, 0x66, 0x54, 0xBA, 0xB7, 0x72, 0x84, 0xB3, 0x64, 0xE1, 0x6C, 0x50, 0x38, 0xC8, 0x12, 0x2A, 0xDB, 0x94, 0xEB, 0x53, 0x13, 0x9B, 0x1A, 0xC3, 0x6E, 0xA4, 0xF6},
    {0x61, 0x3D, 0x34, 0x01, 0x46, 0xE0, 0x01, 0x00, 0x82, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xC5, 0x9F, 0x08, 0x99, 0xD3, 0x09, 0x3C, 0x78, 0x4D, 0x06, 0x74, 0x54, 0xDC, 0x09, 0xB5, 0x00, 0x00, 0x00, 0x00, 0x56, 0x8B, 0x7F, 0xBB, 0x69, 0x2A, 0x21, 0x3D, 0x6E, 0xE5, 0xEF, 0x3D, 0x71, 0x38, 0x70, 0x3E, 0x1C, 0xD3, 0xC5, 0x3E, 0xB9, 0xF0, 0x0E, 0x3F, 0x6B, 0x9F, 0x39, 0x3F, 0x77, 0x0D, 0x5B, 0x3F, 0xD4, 0x9B, 0x6D, 0x3F, 0x37, 0x64, 0x72, 0x3F, 0x72, 0x56, 0x6D, 0x3F, 0x98, 0xB0, 0xD3, 0x6B, 0x62, 0xE4, 0x67, 0x2C, 0x84, 0x62, 0x9C, 0xD1, 0x24, 0x48, 0xF5, 0x0A, 0x4D, 0x7D, 0x3E, 0x3F, 0xE8, 0xE9, 0x35, 0x3F, 0x4A, 0x91, 0x29, 0x3F, 0x12, 0x57, 0x1B, 0x3F, 0x9B, 0xB3, 0x0E, 0x3F, 0x70, 0xDB, 0x06, 0x3F, 0xB4, 0x67, 0x04, 0x3F, 0x91, 0x4F, 0x05, 0x3F, 0x29, 0xAC, 0x05, 0x3F, 0xE2, 0x9A, 0x02, 0x3F, 0xEB, 0xF4, 0xF8, 0x3E, 0x02, 0x69, 0xE9, 0x3E, 0x98, 0x43, 0xC1, 0xAC, 0x00, 0xFD, 0x34, 0xA8, 0xDE, 0x49, 0xFB, 0xCB, 0xC9, 0x69, 0x70, 0x1E, 0x44, 0xC6, 0xB1, 0x3E, 0x82, 0x22, 0xA8, 0x3E, 0xBD, 0xB0, 0x9C, 0x3E, 0x35, 0xEC, 0x90, 0x3E, 0xD6, 0xC2, 0x84, 0x3E, 0xE0, 0xF2, 0x71, 0x3E, 0x64, 0x30, 0x5C, 0x3E, 0x6E, 0xAA, 0x49, 0x3E, 0x1B, 0x24, 0x3C, 0x3E, 0xA3, 0xD1, 0x34, 0x3E, 0x4E, 0x84, 0x32, 0x3E, 0x70, 0x14, 0x2E, 0x3E, 0x6E, 0x50, 0x0E, 0xEA, 0x2F, 0x78, 0x5C, 0xD6, 0xCD, 0x08, 0xF8, 0xBF, 0x56, 0xE8, 0x29, 0x5E, 0x26, 0xEE, 0xA6, 0x3D, 0xA4, 0x71, 0x3C, 0x3D, 0x07, 0xB8, 0x73, 0x3C, 0x7D, 0x61, 0x7F, 0x8B, 0x96, 0x79, 0x40, 0x93, 0xFB, 0x4A, 0xC3, 0x97, 0x24, 0x42, 0x5B, 0x66, 0x57, 0x0F, 0xA2, 0x91, 0x73, 0xF5, 0x46, 0xF2, 0xFB, 0x71, 0xBC, 0xA3, 0x7F, 0x96, 0x95, 0xA1, 0x96, 0x34, 0xB2, 0x49, 0x45, 0x9B, 0x35, 0x5E, 0x94, 0xE0, 0x8F, 0x9A, 0x6C, 0x5F, 0xDA, 0x76, 0x83, 0xD2, 0x75, 0x96, 0x86, 0xB1, 0x7D, 0x16, 0x44, 0xDA, 0x33, 0xD2, 0xD7, 0x34, 0x57, 0xF0, 0xFB, 0xC5, 0xAD, 0x8F, 0xA8, 0xE5, 0x09, 0xDE, 0x0D, 0x7A, 0xA1, 0x08, 0x87, 0xE6, 0xED, 0x43, 0x07, 0x55, 0x25, 0x06, 0x39, 0x17, 0xEA, 0xC8, 0xEC, 0x32, 0x89, 0x81, 0x71, 0xDC, 0x15, 0xC9, 0x94, 0xDD, 0xF2, 0x0F, 0x22, 0xD2, 0xEC, 0xA5, 0x3F, 0x7F, 0x7F, 0x69, 0x11, 0xF0, 0xF7, 0x9A, 0xAA, 0x58, 0x8C, 0x07, 0x40, 0xA7, 0x2C, 0x4F, 0x1D, 0xF4, 0x19, 0x70, 0x19, 0xD6, 0x89, 0x81, 0x30, 0x40, 0x76, 0x02, 0xD5, 0x69, 0x19, 0x4F, 0x8F, 0xCF, 0x38, 0xF8, 0xC1, 0x6C, 0x55, 0xF3, 0x78, 0xAC, 0x0D, 0x12, 0xC2, 0xAD, 0x49, 0x36, 0xFD, 0x65, 0x7E, 0x57, 0x71, 0x89, 0xB7, 0xD5, 0x5E, 0x4B, 0x64, 0xF0, 0x77, 0x04, 0x55, 0xCC, 0x35, 0x19, 0x41, 0x49, 0x01, 0xE6, 0x1E, 0xD7, 0x01, 0xBC, 0x5C, 0x6B, 0x0F, 0x3F, 0x4D, 0x77, 0xC8, 0x73, 0x94, 0xF2, 0x67, 0x3E, 0x48, 0xD3, 0x3B, 0x8F, 0xE8, 0x83, 0x77, 0x5C, 0x82, 0xBE, 0xFF, 0x10, 0x66, 0x4D, 0x45, 0x53, 0xCC, 0x1D, 0x91, 0xD0, 0x0B, 0x6B, 0x54, 0x3A, 0xF6, 0xAA, 0xE6, 0x8F, 0x82, 0x0F, 0xAF, 0xDF, 0xF9, 0xCF, 0x4F, 0x75, 0xEC, 0x52, 0x97, 0xEF, 0x77, 0x62, 0x0D, 0xC1, 0xF7, 0xDA, 0xAC, 0xF5, 0xDA, 0x12, 0x89, 0x48, 0xBB, 0x83, 0x52, 0x3E, 0x55, 0x37, 0xFF, 0x8E, 0xC1, 0x9E, 0x38, 0xAF, 0xFE, 0x4A, 0xE8, 0xB1, 0x1C, 0x9E, 0x1C, 0x7E, 0xD9, 0x64, 0x77, 0xA6, 0x10, 0x14, 0x68, 0x1B, 0x0F, 0xD9},
    {0x61, 0x3D, 0x34, 0x01, 0x46, 0xE0, 0x01, 0x00, 0x73, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0xD7, 0x2C, 0x83, 0x62, 0xBD, 0x6F, 0x49, 0x12, 0xC6, 0x54, 0x07, 0xB4, 0x0D, 0xBC, 0x45, 0x00, 0x00, 0x00, 0x00, 0x7B, 0x1E, 0xEB, 0xBB, 0xA9, 0x87, 0x55, 0x3D, 0x0E, 0xD7, 0x27, 0x3E, 0x21, 0x33, 0xA4, 0x3E, 0xBA, 0x29, 0xFB, 0x3E, 0x93, 0x56, 0x24, 0x3F, 0x0F, 0x84, 0x41, 0x3F, 0x65, 0x49, 0x55, 0x3F, 0x82, 0x25, 0x61, 0x3F, 0x94, 0x66, 0x67, 0x3F, 0x98, 0x58, 0x69, 0x3F, 0x23, 0xC9, 0xB2, 0xE6, 0x2D, 0xEF, 0x91, 0xB4, 0xC3, 0x04, 0x76, 0xD9, 0xBD, 0x2D, 0xB7, 0xFF, 0x9C, 0x38, 0x5C, 0x3F, 0xB0, 0xE2, 0x52, 0x3F, 0x28, 0x1C, 0x48, 0x3F, 0xEE, 0x63, 0x3E, 0x3F, 0xDD, 0x9B, 0x35, 0x3F, 0xD7, 0x81, 0x2D, 0x3F, 0x39, 0x34, 0x26, 0x3F, 0x76, 0xFC, 0x1F, 0x3F, 0x30, 0x66, 0x1B, 0x3F, 0x58, 0x57, 0x17, 0x3F, 0x24, 0xAA, 0x12, 0x3F, 0x01, 0x51, 0x0D, 0x3F, 0xB9, 0x2C, 0x84, 0x38, 0xD5, 0x7E, 0xF8, 0x24, 0xAB, 0x10, 0x8B, 0xAE, 0x39, 0xE4, 0x4C, 0x49, 0x28, 0xE9, 0xD4, 0x3E, 0xF0, 0x8D, 0xC2, 0x3E, 0x36, 0xA1, 0xB0, 0x3E, 0x35, 0x97, 0x9F, 0x3E, 0x69, 0xD6, 0x8F, 0x3E, 0xA6, 0x6C, 0x82, 0x3E, 0xB8, 0x2C, 0x70, 0x3E, 0x31, 0x11, 0x64, 0x3E, 0x5E, 0xEF, 0x5A, 0x3E, 0x13, 0x19, 0x4E, 0x3E, 0xA7, 0x53, 0x40, 0x3E, 0xB1, 0x62, 0x31, 0x3E, 0x61, 0x98, 0x77, 0x1A, 0x19, 0x4D, 0x11, 0x34, 0x3C, 0x2A, 0x9D, 0x54, 0xA4, 0xDB, 0x52, 0x81, 0x1E, 0xAA, 0xA0, 0x3D, 0x8D, 0x8D, 0x47, 0x3D, 0x1C, 0x78, 0x8E, 0x3C, 0xE1, 0xCE, 0x3B, 0xFC, 0xA8, 0xA3, 0xD6, 0x9F, 0x7A, 0x59, 0xE5, 0x45, 0x18, 0x6D, 0x73, 0x60, 0x83, 0x62, 0x16, 0x93, 0xB6, 0x6D, 0x14, 0x96, 0x96, 0x5B, 0xDD, 0x7F, 0x80, 0xCE, 0xE5, 0xE4, 0x71, 0x34, 0xD3, 0x8E, 0xC4, 0x40, 0x5F, 0xB4, 0x11, 0xF5, 0x83, 0x21, 0x08, 0x27, 0xA3, 0x21, 0xEA, 0x58, 0x72, 0xB3, 0x61, 0x8B, 0xDD, 0xE7, 0xDF, 0xA9, 0x61, 0xD6, 0xC5, 0xE5, 0x86, 0xE7, 0x59, 0xE6, 0x92, 0xEB, 0xD5, 0xBC, 0xEF, 0xAC, 0x73, 0xD6, 0x9E, 0x7F, 0x47, 0x99, 0x5D, 0x0A, 0xC7, 0xAB, 0x7F, 0xF5, 0x29, 0xC2, 0xB4, 0x64, 0xCD, 0x67, 0x20, 0xC3, 0x0A, 0x4A, 0xD9, 0xD8, 0xFD, 0x21, 0xD3, 0x1B, 0xF7, 0x1A, 0xD5, 0x68, 0xBB, 0x4B, 0xA5, 0x86, 0x10, 0x13, 0xAB, 0x31, 0x9F, 0x46, 0x65, 0x77, 0xD4, 0x0F, 0xD5, 0x72, 0x3A, 0x81, 0x4A, 0xBF, 0xCD, 0xDA, 0x66, 0xB1, 0x64, 0x4F, 0xAF, 0x94, 0xCB, 0x1F, 0x42, 0xBB, 0x9B, 0xE0, 0xEA, 0x37, 0x6F, 0x58, 0x53, 0x56, 0x00, 0x3F, 0x51, 0xC1, 0x90, 0x17, 0x3D, 0x49, 0x14, 0x47, 0x3A, 0x9F, 0x41, 0xDE, 0xB2, 0x79, 0xAE, 0x56, 0x20, 0x7F, 0x02, 0xDF, 0x7E, 0x21, 0xAF, 0xAF, 0x72, 0x7F, 0xD9, 0xF8, 0xD3, 0x99, 0x69, 0xA8, 0x4B, 0x6B, 0xC5, 0x59, 0x2C, 0x12, 0x08, 0xFD, 0xDD, 0x15, 0xDE, 0xFD, 0x79, 0x30, 0x7E, 0xF6, 0x1F, 0xFC, 0x6D, 0x8F, 0x39, 0xE8, 0x62, 0xAB, 0xD1, 0x99, 0xD9, 0xCA, 0x31, 0x3B, 0x6E, 0x5E, 0xB6, 0x0B, 0xDF, 0x67, 0x9E, 0x10, 0x30, 0x78, 0x0A, 0x36, 0xED, 0x38, 0xED, 0xB1, 0x65, 0x16, 0xBE, 0x6C, 0x7D, 0x62, 0x7E, 0x6A, 0x8E, 0x4D, 0xEF, 0xFD, 0x99, 0x65, 0x0D, 0x77, 0x4B, 0xF5, 0xEB, 0x89, 0x20, 0x18, 0xCB, 0xC8, 0xC3, 0xB0, 0xE4, 0x06, 0x15, 0xDB, 0xF4, 0x97, 0x4B, 0xB0, 0x8C, 0x35, 0x33, 0xC6, 0xA8, 0x99, 0x28, 0xEF, 0x75, 0xD0, 0x41, 0x40, 0xF3, 0x54},
    {0x61, 0x3D, 0x34, 0x01, 0x46, 0xE0, 0x01, 0x00, 0x6E, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0xA8, 0xAC, 0x06, 0x73, 0xC0, 0x53, 0x7A, 0x9B, 0x3F, 0xF2, 0x41, 0x0C, 0xCD, 0x0B, 0x96, 0x00, 0x00, 0x00, 0x00, 0x13, 0xF5, 0x51, 0xBB, 0xAF, 0xC2, 0x4B, 0x3D, 0x27, 0x19, 0x20, 0x3E, 0xDD, 0x1B, 0xA1, 0x3E, 0xD3, 0x90, 0x00, 0x3F, 0xD5, 0x4E, 0x2F, 0x3F, 0x46, 0x48, 0x55, 0x3F, 0x90, 0x65, 0x6E, 0x3F, 0x77, 0x2B, 0x7A, 0x3F, 0x30, 0xA0, 0x79, 0x3F, 0x09, 0x12, 0x6F, 0x3F, 0x68, 0x13, 0x05, 0xB8, 0xBC, 0xD3, 0x48, 0x56, 0x56, 0x50, 0x45, 0x1B, 0x13, 0x6D, 0x36, 0xF1, 0xF4, 0xDE, 0x3D, 0x3F, 0x6B, 0x2C, 0x35, 0x3F, 0x53, 0x91, 0x2C, 0x3F, 0xE3, 0x87, 0x25, 0x3F, 0x64, 0x82, 0x20, 0x3F, 0x4A, 0x76, 0x1D, 0x3F, 0xD1, 0x12, 0x1B, 0x3F, 0xA9, 0xF4, 0x17, 0x3F, 0x99, 0xDE, 0x13, 0x3F, 0x13, 0x21, 0x0F, 0x3F, 0xE6, 0xBF, 0x09, 0x3F, 0xBE, 0x59, 0x04, 0x3F, 0xE9, 0x84, 0x58, 0xEA, 0xF0, 0x47, 0xBD, 0xDC, 0xAA, 0x8F, 0xEB, 0x7C, 0x4A, 0xA4, 0xFA, 0x1D, 0x62, 0xA5, 0xBA, 0x3E, 0x9C, 0xF8, 0xB1, 0x3E, 0x9C, 0x99, 0xA9, 0x3E, 0xEE, 0x85, 0xA1, 0x3E, 0xEC, 0x3B, 0x9D, 0x3E, 0x16, 0x51, 0x9B, 0x3E, 0x7E, 0xB7, 0x98, 0x3E, 0xEE, 0xE6, 0x92, 0x3E, 0xDF, 0xF6, 0x86, 0x3E, 0x46, 0x2C, 0x6E, 0x3E, 0x37, 0xB3, 0x4C, 0x3E, 0xD4, 0x0E, 0x32, 0x3E, 0x88, 0xFD, 0x9C, 0xED, 0x70, 0x36, 0xAF, 0xBE, 0xBD, 0xCC, 0x43, 0x76, 0xD7, 0xC5, 0x15, 0x60, 0xF2, 0x39, 0xA8, 0x3D, 0x9E, 0xBC, 0x4B, 0x3D, 0x6D, 0x13, 0x98, 0x3C, 0xB6, 0xC4, 0xB0, 0x97, 0xA3, 0x50, 0x3B, 0xB1, 0xED, 0x52, 0x39, 0x33, 0x68, 0x38, 0x38, 0xF4, 0xEA, 0x7F, 0x32, 0xF6, 0x95, 0xF1, 0x3A, 0xD4, 0xE5, 0xC8, 0x88, 0x34, 0x86, 0x33, 0xEA, 0x5F, 0x55, 0xB5, 0x38, 0x60, 0xF6, 0xAB, 0x8D, 0xEB, 0xCC, 0x34, 0x9D, 0x91, 0xF7, 0xB6, 0x18, 0x1C, 0x47, 0x4D, 0x38, 0x59, 0x90, 0x1E, 0xE0, 0xCD, 0x40, 0x97, 0x13, 0xB4, 0xC5, 0x97, 0x8A, 0xC7, 0xF5, 0xC2, 0x29, 0xC1, 0xC9, 0x88, 0x68, 0x4C, 0x48, 0x8E, 0xE4, 0x96, 0xAC, 0xA3, 0x8D, 0xF8, 0x6B, 0x92, 0xEB, 0x27, 0x0C, 0xD4, 0x99, 0x01, 0x74, 0xAF, 0x18, 0x3F, 0xB6, 0x97, 0x65, 0x52, 0x79, 0x47, 0x02, 0xB7, 0x40, 0x60, 0x90, 0xA6, 0x1A, 0xC9, 0x65, 0x75, 0xFA, 0xCB, 0xA3, 0x89, 0x7E, 0xDB, 0xC1, 0x44, 0xAF, 0x43, 0xEB, 0xB2, 0x24, 0x7F, 0xD9, 0x0C, 0x9F, 0x42, 0x09, 0xB5, 0xF1, 0x3C, 0xB8, 0x07, 0x1E, 0xA9, 0x8B, 0x8F, 0x69, 0x03, 0x60, 0x0D, 0xA9, 0x1E, 0xD6, 0x16, 0x39, 0x14, 0x3A, 0xC9, 0xF9, 0xDB, 0xC9, 0x42, 0x36, 0x89, 0x05, 0xA4, 0x8E, 0x7D, 0xEE, 0xFB, 0x97, 0xDD, 0xE0, 0x57, 0xF9, 0xED, 0xA9, 0x94, 0x62, 0xAD, 0xD0, 0xB5, 0xB5, 0x0C, 0xA3, 0xEF, 0x69, 0x14, 0x4C, 0x4E, 0xA2, 0xC9, 0x23, 0x26, 0x13, 0x47, 0x28, 0x39, 0x7B, 0x43, 0xC3, 0x33, 0xCF, 0x50, 0xE1, 0x41, 0xBB, 0xB1, 0xE8, 0x64, 0x3A, 0x70, 0x72, 0xE5, 0x31, 0x95, 0xB9, 0xB8, 0x23, 0xD9, 0x5F, 0x45, 0xF9, 0x84, 0x76, 0xD8, 0xE0, 0x0F, 0x1B, 0xF8, 0x62, 0xF4, 0xC0, 0x2D, 0x24, 0x49, 0x23, 0x6A, 0x15, 0x67, 0x00, 0x20, 0xDE, 0x4F, 0xF2, 0x5C, 0x5E, 0xE8, 0x30, 0x76, 0x0F, 0xAC, 0x06, 0x0F, 0x3E, 0x4D, 0x58, 0xD6, 0xC5, 0xFC, 0x6E, 0x64, 0x62, 0x93, 0xF1, 0x2D, 0x37, 0x97, 0x2A, 0xDE, 0x0C, 0x94, 0xB3, 0x40, 0x26, 0x91, 0x81, 0xCB, 0xDA, 0x78, 0x7F, 0x73},
    {0x61, 0x3D, 0x34, 0x01, 0x46, 0xE0, 0x01, 0x00, 0x82, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x91, 0x08, 0xF2, 0xB8, 0xD7, 0x7D, 0x92, 0x22, 0xDE, 0xD1, 0x1B, 0x22, 0x60, 0x7D, 0x2B, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x56, 0x66, 0xBB, 0x03, 0xD7, 0x53, 0x3D, 0x9E, 0xB1, 0x2E, 0x3E, 0x60, 0xE5, 0xB4, 0x3E, 0x52, 0xB0, 0x0F, 0x3F, 0x94, 0xAB, 0x3D, 0x3F, 0x36, 0xB8, 0x5D, 0x3F, 0xD4, 0x32, 0x70, 0x3F, 0x0E, 0x65, 0x76, 0x3F, 0x37, 0x7D, 0x73, 0x3F, 0x72, 0x62, 0x6C, 0x3F, 0x67, 0xAF, 0xD2, 0x26, 0xE6, 0x40, 0x6C, 0xC6, 0xAD, 0x28, 0x6D, 0x25, 0x78, 0x5D, 0x3A, 0x11, 0xFF, 0x8E, 0x43, 0x3F, 0xB1, 0xAF, 0x35, 0x3F, 0x48, 0xFC, 0x27, 0x3F, 0xD7, 0x7A, 0x1C, 0x3F, 0xCC, 0x1F, 0x14, 0x3F, 0x8F, 0x4E, 0x0F, 0x3F, 0x3C, 0x06, 0x0D, 0x3F, 0x05, 0x45, 0x09, 0x3F, 0xC4, 0x5A, 0x03, 0x3F, 0x8D, 0x02, 0xFA, 0x3E, 0x1E, 0xE8, 0xED, 0x3E, 0xBE, 0x74, 0xE1, 0x3E, 0xD9, 0x03, 0xD4, 0xD2, 0x10, 0x10, 0xB7, 0x1E, 0x42, 0x8F, 0xD1, 0x7E, 0xD5, 0x8C, 0x43, 0x21, 0x4C, 0xC1, 0xA6, 0x3E, 0xC9, 0x98, 0xA0, 0x3E, 0xD1, 0x96, 0x9E, 0x3E, 0x4C, 0xEA, 0x9C, 0x3E, 0x45, 0x47, 0x99, 0x3E, 0x3C, 0x9A, 0x92, 0x3E, 0xC5, 0x52, 0x88, 0x3E, 0x0A, 0x16, 0x78, 0x3E, 0x55, 0xA0, 0x5D, 0x3E, 0x3E, 0xE8, 0x43, 0x3E, 0x2F, 0xCE, 0x29, 0x3E, 0xCE, 0xB8, 0x14, 0x3E, 0x96, 0x77, 0xA8, 0x74, 0xBC, 0x75, 0xBC, 0x9E, 0x81, 0xFD, 0xBA, 0x95, 0x97, 0xA7, 0xB6, 0x48, 0x9C, 0xE5, 0xAB, 0x3D, 0xD7, 0x17, 0x3A, 0x3D, 0xE6, 0x5A, 0x7F, 0x3C, 0x1A, 0x5B, 0x5B, 0xAC, 0xD5, 0x86, 0xDD, 0x04, 0x49, 0x15, 0x06, 0x2A, 0x16, 0x53, 0x71, 0x9C, 0xFA, 0x38, 0x9C, 0x3C, 0x20, 0xCC, 0xEE, 0xA3, 0xA9, 0x19, 0x6F, 0x07, 0x0E, 0x6C, 0x0B, 0x98, 0x32, 0x72, 0x7D, 0x23, 0x45, 0xDD, 0x2F, 0x06, 0x83, 0x67, 0xC3, 0x00, 0xA3, 0x4D, 0x4D, 0xB7, 0xAC, 0x81, 0xA4, 0x2B, 0x03, 0xEF, 0xAA, 0x78, 0x8B, 0x9C, 0x31, 0x17, 0xE5, 0x6A, 0x23, 0x86, 0x00, 0xD0, 0x9C, 0xC9, 0xA5, 0xE8, 0xE9, 0x28, 0x1A, 0x0F, 0x23, 0x46, 0x5B, 0xBB, 0x0E, 0x7A, 0xF2, 0x9F, 0x4F, 0xEA, 0x7F, 0x69, 0xC1, 0xC5, 0x31, 0xC9, 0x44, 0xFE, 0x77, 0x65, 0xD6, 0xDE, 0xE3, 0xB7, 0x98, 0xE0, 0x32, 0xF6, 0x26, 0xB5, 0xA5, 0xFF, 0x03, 0xF9, 0x6F, 0xCA, 0xE8, 0x5D, 0xA2, 0x7A, 0x3F, 0x20, 0xA0, 0x25, 0x62, 0x8D, 0xF8, 0x68, 0x9D, 0xC1, 0xFB, 0x48, 0x12, 0x78, 0x25, 0xD4, 0xBC, 0xCD, 0x99, 0xC4, 0xA4, 0x75, 0xC8, 0x18, 0x26, 0x69, 0x40, 0x8A, 0xFD, 0xD6, 0x00, 0x7D, 0xC6, 0x54, 0x41, 0xF5, 0x19, 0xE1, 0xCE, 0x70, 0xB0, 0xE5, 0x96, 0xE8, 0x53, 0x5E, 0xB9, 0xA8, 0xB1, 0xF1, 0xD9, 0x02, 0x49, 0x64, 0x49, 0x2B, 0xD4, 0x32, 0xE2, 0xE2, 0xDB, 0xD3, 0xB2, 0x4E, 0x9E, 0x04, 0x2A, 0xCF, 0x21, 0x99, 0x2E, 0xB1, 0x93, 0x80, 0x3B, 0x0B, 0xB0, 0x4A, 0xFB, 0xED, 0x6A, 0x7C, 0xE4, 0x6A, 0x63, 0x9B, 0xB7, 0xE3, 0x22, 0xF3, 0x8D, 0x7D, 0x46, 0x73, 0xF7, 0x05, 0x0E, 0x02, 0x2F, 0x1B, 0xB6, 0x08, 0x23, 0x78, 0x32, 0x52, 0x87, 0x72, 0xE7, 0x15, 0x68, 0xF8, 0x11, 0x46, 0xDB, 0x84, 0x11, 0xA3, 0x02, 0x4B, 0xA3, 0x28, 0x4C, 0x1A, 0x09, 0xE9, 0x18, 0x8C, 0x34, 0xFA, 0x4F, 0xF4, 0x5A, 0xB6, 0x43, 0x33, 0x7F, 0xDA, 0xA2, 0xD8, 0x6D, 0x30, 0xF7, 0xA3, 0x80, 0xE0, 0xD8, 0x5B, 0x32, 0xC6, 0x05, 0x23, 0xCB, 0x9D, 0x07, 0x7E, 0x0B, 0x2A}};
uint8_t vectorSystolicDystolic[5][2] = {{120, 80}, {130, 100}, {115, 90}, {110, 70}, {130, 70}};
ReWire_MAX32664::ReWire_MAX32664(TwoWire *i2c_instance, int pin_mfio, int pin_reset, int i2c_address)
{
    ConfigurePinsAndI2C(i2c_instance, pin_mfio, pin_reset, i2c_address);
}

void ReWire_MAX32664::ConfigurePinsAndI2C(TwoWire *i2c_instance, int pin_mfio, int pin_reset, int i2c_address)
{
    wire_instance = i2c_instance;
    mfio_pin = pin_mfio;
    reset_pin = pin_reset;
    max32664_i2c_address = i2c_address;
}

uint8_t ReWire_MAX32664::Begin(uint8_t &device_mode, TwoWire *i2c_instance, int pin_mfio, int pin_reset, int i2c_address)
{
    ConfigurePinsAndI2C(i2c_instance, pin_mfio, pin_reset, i2c_address);
    return Begin(device_mode);
}

/// @brief Initializes communication with the MAX32664
/// @param device_mode the resulting operating mode of the MAX32664
/// @return the resulting status byte of the read operation
uint8_t ReWire_MAX32664::Begin(uint8_t &device_mode)
{
    // Set the MFIO and reset pins to be output pins
    pinMode(mfio_pin, OUTPUT);
    pinMode(reset_pin, OUTPUT);

    // As described in the datasheet, to enter "application mode", we must set the reset pin low for 10 ms,
    // and also set the MFIO pin high.
    digitalWrite(mfio_pin, HIGH);
    digitalWrite(reset_pin, LOW);
    delay(10);

    // As described in the datasheet, after 10 ms has elapsed, we must set the reset pin to high.
    digitalWrite(reset_pin, HIGH);

    // After approximately 50 ms, the MAX32664 is now in "application mode".
    // After approximately 1 second from when the reset pin was set to high, the application should have
    // completed initialization and the device is now ready to accept I2C commands.
    delay(1000);

    // Set the mfio pin to INPUT_PULLUP. It can be used to receive interrupts.
    pinMode(mfio_pin, INPUT_PULLUP);

    // Read the device's operating mode and return the result to the caller
    uint8_t status_byte = ReadDeviceMode(device_mode);
    return status_byte;
}

/// @brief Reads a single sample from the output fifo, working under the assumption the sample
///     is a sensor+algorithm sample w/o accelerometer (so 21 bytes in size)
/// @param sample The sample
/// @return The status of the read operation
uint8_t ReWire_MAX32664::ReadSample_SensorAndAlgorithm(MAX32664_Data &sample)
{
    uint8_t read_length = 21;
    uint8_t read_buffer[21] = {0};

    // Read the sample
    uint8_t read_status = ReadOutputFifo(read_buffer, read_length);

    // Parse the sample
    uint32_t ir0 = ((uint32_t)read_buffer[0]) << 16;
    uint32_t ir1 = ((uint32_t)read_buffer[1]) << 8;
    uint32_t ir2 = ((uint32_t)read_buffer[2]);
    uint32_t ir_final = (uint32_t)(ir0 | ir1 | ir2) / 10;

    uint32_t red0 = ((uint32_t)read_buffer[3]) << 16;
    uint32_t red1 = ((uint32_t)read_buffer[4]) << 8;
    uint32_t red2 = ((uint32_t)read_buffer[5]);
    uint32_t red_final = (uint32_t)(red0 | red1 | red2) / 10;

    uint16_t hr = (uint16_t(read_buffer[12]) << 8);
    hr |= (read_buffer[13]);
    hr /= 10;

    uint8_t hr_confidence = read_buffer[14];

    uint16_t spo2 = uint16_t(read_buffer[15]) << 8;
    spo2 |= read_buffer[16];
    spo2 /= 10;

    // Assign these values to the MAX32664_Data object
    sample.ir = ir_final;
    sample.red = red_final;
    sample.hr = hr;
    sample.hr_confidence = hr_confidence;
    sample.spo2 = spo2;
    sample.algorithm_state = read_buffer[17];
    sample.algorithm_status = read_buffer[18];
    sample.interbeat_interval = ((read_buffer[19] << 8) | read_buffer[20]) / 1000;

    // Return the result of the read operation
    return read_status;
}

/// @brief This function executes all the commands necessary to start the HR/SpO2 algorithm and also include PPG data.
/// @return The status result
uint8_t ReWire_MAX32664::ConfigureDevice_SensorAndAlgorithm()
{
    // In this function, we are following the steps outlined in Table 8 (section 3.2) of
    //   the document "measuring-heart-rate-and-spo2-using-the-max32664a.pdf".

    // Step 1.1: Set SpO2 calibration coefficients
    //   We are skipping this step for now.

    // Step 1.2: Set output mode to sensor + algorithm data (0x03, streamed data will include
    //   PPG and algorithm data, but NOT accelerometer data).
    uint8_t status_byte = SetOutputMode_OutputFormat(MAX32664_OutputModeFormat::SensorData_And_AlgorithmData);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.3: Set sensor hub interrupt threshold to 0x0F (the value used in the datasheet example).
    status_byte = SetOutputMode_FifoInterruptThreshold(0x0F);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.4: Enable the AGC (automatic gain control)
    status_byte = SetAlgorithmMode_EnableAGC(true);
    delay(200);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.5: Enable the accelerometer with the sensor hub
    //   We are skipping this step because we do not currently have
    //   an accelerometer.

    // Step 1.6: Enable the AFE ("analog front end" - the MAX30101 in this case)
    status_byte = EnableSensor(true);
    delay(40);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.7: Enable the HR/SpO2 algorithm.
    status_byte = EnableAlgorithmMode_MaximFast(0x01);
    delay(10);

    // Return the result of the final operation
    return status_byte;
}

/// @brief Reads the status of the sensor hub
/// @param status the sensor hub status
///     [0] = Err0
///         No error = 0
///         Sensor communication problem = 1
///     [1] = Err1 / Not used
///     [2] = Err2 / Not used
///     [3] = DataRdyInt
///         FIFO below threshold = 0
///         FIFO filled = 1
///     [4] = FifoOutOvrInt
///         No FIFO overflow = 0
///         FIFO overflowed / data lost = 1
///     [5] = FifoInOvrInt
///         No FIFO overflow = 0
///         FIFO overflowed / data lost = 1
///     [6] = HostAccelUfInt
///         No underflow = 0
///         Host data to input FIFO has slowed = 1
/// @return the status byte of the read operation
uint8_t ReWire_MAX32664::ReadSensorHubStatus(uint8_t &status)
{
    uint8_t status_byte = read_byte(MAX32664_CommandFamilyByte::ReadSensorHubStatus, 0x00, status);
    return status_byte;
}

/// @brief Reads the device operating mode
/// @param device_mode will be set to: 0x00 = Application operating mode, 0x02 = Reset, 0x08 = Bootloader operating mode
/// @return the status byte of the read operation
uint8_t ReWire_MAX32664::ReadDeviceMode(uint8_t &device_mode)
{
    uint8_t status_byte = read_byte(MAX32664_CommandFamilyByte::ReadDeviceMode, 0x00, device_mode);
    return status_byte;
}

/// @brief Reads the firmware version of the MAX32664
/// @param major_version MAX32664 major version number
/// @param minor_version MAX32664 minor version number
/// @param revision_number MAX32664 revision number
/// @return the status byte of the read operation
uint8_t ReWire_MAX32664::ReadSensorHubVersion(uint8_t &major_version, uint8_t &minor_version, uint8_t &revision_number)
{
    uint8_t status_byte;

    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(MAX32664_CommandFamilyByte::ReadIdentity);
    wire_instance->write(0x03);
    wire_instance->endTransmission();

    wire_instance->requestFrom(max32664_i2c_address, 4);
    status_byte = wire_instance->read();
    delayMicroseconds(10);
    major_version = wire_instance->read();
    delayMicroseconds(10);
    minor_version = wire_instance->read();
    delayMicroseconds(10);
    revision_number = wire_instance->read();
    delayMicroseconds(10);

    return status_byte;
}

/// @brief Sets the operating mode of the MAX32664
/// @param operating_mode 0x00 = exit bootloader/enter application, 0x01 = shutdown, 0x02 = reset, 0x08 = enter bootloader
/// @return the status byte of the write operation
uint8_t ReWire_MAX32664::SetDeviceOperatingMode(MAX32664_DeviceOperatingMode operating_mode)
{
    return write_byte(MAX32664_CommandFamilyByte::SetDeviceMode, 0x00, operating_mode);
}

/// @brief Sets the output format of the sensor data
/// @param output_format the output format of the sensor data
/// @return the status byte of the write operation
uint8_t ReWire_MAX32664::SetOutputMode_OutputFormat(MAX32664_OutputModeFormat output_format)
{
    return write_byte(MAX32664_CommandFamilyByte::SetOutputMode, 0x00, output_format);
}

/// @brief Sets the threshold for the FIFO interrupt bit/pin. The MFIO pin is used as the interrupt pin.
/// @param interrupt_threshold 0x01 to 0xFF. Sensor interrupt threshold for FIFO.
/// @return the status byte of the write operation
uint8_t ReWire_MAX32664::SetOutputMode_FifoInterruptThreshold(uint8_t interrupt_threshold)
{
    return write_byte(MAX32664_CommandFamilyByte::SetOutputMode, 0x01, interrupt_threshold);
}

/// @brief Enable the AGC algorithm
/// @param enable 0 = disable, 1 = enable
/// @return the status byte of the write operation
uint8_t ReWire_MAX32664::SetAlgorithmMode_EnableAGC(bool enable)
{
    return write_byte_with_custom_cmd_delay(MAX32664_CommandFamilyByte::EnableAlgorithm, 0x00, enable, 20);
}

/// @brief Enable the MAX30101 sensor
/// @param enable 0 = disable, 1 = enable
/// @return the status byte of the write operation
uint8_t ReWire_MAX32664::EnableSensor(bool enable)
{
    return write_byte_with_custom_cmd_delay(MAX32664_CommandFamilyByte::EnableSensorMode, 0x03, enable, 40);
}

/// @brief Enable the WHRM MaximFast algorithm.
/// @param mode 0x00 = disable, 0x01 = mode 1 report, 0x02 = mode 2 extended report
/// @return
uint8_t ReWire_MAX32664::EnableAlgorithmMode_MaximFast(uint8_t mode)
{
    return write_byte_with_custom_cmd_delay(MAX32664_CommandFamilyByte::EnableAlgorithm, 0x02, mode, 40 + 20);
}

/// @brief Reads the number of available samples in the output FIFO on the MAX32664
/// @param num_samples The number of available samples
/// @return the status byte of the read operation
uint8_t ReWire_MAX32664::ReadNumberAvailableSamples(uint8_t &num_samples)
{
    uint8_t status_byte;

    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(MAX32664_CommandFamilyByte::ReadOutputFIFO);
    wire_instance->write(0x00);
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, 2);
    status_byte = wire_instance->read();
    num_samples = wire_instance->read();

    return status_byte;
}

/// @brief Reads data stored in the output FIFO
/// @param read_buffer the buffer to hold the bytes that are read
/// @param read_length the number of bytes to read
/// @return The status of the read operation
uint8_t ReWire_MAX32664::ReadOutputFifo(uint8_t *read_buffer, uint8_t read_length)
{
    return read_multiple_bytes(MAX32664_CommandFamilyByte::ReadOutputFIFO, 0x01, read_buffer, read_length);
}

uint8_t ReWire_MAX32664::read_byte(uint8_t data1, uint8_t data2, uint8_t &return_byte)
{
    uint8_t status_byte;

    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, 2);
    status_byte = wire_instance->read();
    return_byte = wire_instance->read();
    return status_byte;
}

uint8_t ReWire_MAX32664::read_multiple_bytes(uint8_t data1, uint8_t data2, uint8_t *read_buffer, uint8_t read_length)
{
    uint8_t status_byte;

    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, read_length + 1);
    status_byte = wire_instance->read();
    for (int i = 0; i < read_length; ++i)
    {
        read_buffer[i] = wire_instance->read();
        delayMicroseconds(1);
    }

    return status_byte;
}

uint8_t ReWire_MAX32664::write_byte(uint8_t data1, uint8_t data2, uint8_t data3)
{
    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->write(data3);
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, 1);
    uint8_t status_byte = wire_instance->read();
    return status_byte;
}

uint8_t ReWire_MAX32664::write_byte_with_custom_cmd_delay(uint8_t data1, uint8_t data2, uint8_t data3, uint16_t cmd_delay)
{
    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->write(data3);
    wire_instance->endTransmission();
    delay(cmd_delay);

    wire_instance->requestFrom(max32664_i2c_address, 1);
    uint8_t status_byte = wire_instance->read();
    return status_byte;
}

uint8_t ReWire_MAX32664::write_multiple_bytes(uint8_t data1, uint8_t data2, uint8_t data3, uint8_t *buffer, uint16_t buffer_size)
{
    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->write(data3);
    // wire_instance->write((const uint8_t *)buffer,(size_t) buffer_size);
    for (uint16_t i = 0; i < buffer_size; ++i)
    {
        wire_instance->write(buffer[i]);
        delayMicroseconds(1);
    }
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, 1);
    uint8_t status_byte = wire_instance->read();
    return status_byte;
}
uint8_t ReWire_MAX32664::write_multiple_bytes(uint8_t data1, uint8_t data2, uint8_t data3, uint8_t *buffer, uint16_t buffer_size, uint16_t cmd_delay)
{
    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->write(data3);
    wire_instance->write((const uint8_t *)buffer, (size_t)buffer_size);
    /*for (uint16_t i = 0; i < buffer_size; ++i)
    {
        wire_instance->write(buffer[i]);
        delayMicroseconds(1);
    }*/
    wire_instance->endTransmission();
    delay(cmd_delay);

    wire_instance->requestFrom(max32664_i2c_address, 1);
    uint8_t status_byte = wire_instance->read();
    return status_byte;
}
uint8_t ReWire_MAX32664::loadBPTCalibVector(uint8_t *buffer, uint16_t buffer_size)
{
    uint8_t status = write_multiple_bytes(MAX32664_CommandFamilyByte::SetAlgorithmConfiguration, 0x04, MAX32664_ConfigrationIndex::BPCalibrationData, buffer, buffer_size, 30);
    return status;
}

uint8_t ReWire_MAX32664::setDataTime()
{
    uint8_t dateTimeBuffer[8] = {0xFE, 0xA1, 0x33, 0x01, 0xE0, 0xDF, 0x01, 0x00}; // @note Default value from user guide need to change
    uint8_t status = write_multiple_bytes(MAX32664_CommandFamilyByte::SetAlgorithmConfiguration, 0x04, MAX32664_ConfigrationIndex::SetDateAndTime, dateTimeBuffer, 8, 5);

    return status;
}

uint8_t ReWire_MAX32664::loadSpo2Coefficients(float spo2CalibCoefA, float spo2CalibCoefB, float spo2CalibCoefC)
{
    int32_t A = spo2CalibCoefA * 100000;
    int32_t B = spo2CalibCoefB * 100000;
    int32_t C = spo2CalibCoefC * 100000;
    uint8_t spo2CoefBuffer[12] = {0};
    spo2CoefBuffer[0] = (A & 0xff000000) >> 24;
    spo2CoefBuffer[1] = (A & 0x00ff0000) >> 16;
    spo2CoefBuffer[2] = (A & 0x0000ff00) >> 8;
    spo2CoefBuffer[3] = (A & 0x000000ff);

    spo2CoefBuffer[4] = (B & 0xff000000) >> 24;
    spo2CoefBuffer[5] = (B & 0x00ff0000) >> 16;
    spo2CoefBuffer[6] = (B & 0x0000ff00) >> 8;
    spo2CoefBuffer[7] = (B & 0x000000ff);

    spo2CoefBuffer[8] = (C & 0xff000000) >> 24;
    spo2CoefBuffer[9] = (C & 0x00ff0000) >> 16;
    spo2CoefBuffer[10] = (C & 0x0000ff00) >> 8;
    spo2CoefBuffer[11] = (C & 0x000000ff);

    uint8_t status = write_multiple_bytes(MAX32664_CommandFamilyByte::SetAlgorithmConfiguration, 0x04, MAX32664_ConfigrationIndex::SpO2CalibrationCoefficients, spo2CoefBuffer, 12, 5);

    return status;
}

uint8_t ReWire_MAX32664::EnableBPT_Algorithm(uint8_t mode)
{
    return write_byte_with_custom_cmd_delay(MAX32664_CommandFamilyByte::EnableAlgorithm, 0x04, mode, 600);
}

uint8_t ReWire_MAX32664::ReadSample_BPTSensorAndAlgorithm(MAX32664_Data_VerD &sample)
{
    uint8_t read_length = 29;
    uint8_t read_buffer[29] = {0};

    // Read the sample
    uint8_t read_status = ReadOutputFifo(read_buffer, read_length);

    // Parse the sample
    uint32_t ir0 = ((uint32_t)read_buffer[0]) << 16;
    uint32_t ir1 = ((uint32_t)read_buffer[1]) << 8;
    uint32_t ir2 = ((uint32_t)read_buffer[2]);
    uint32_t ir_final = (uint32_t)(ir0 | ir1 | ir2) / 10;

    uint32_t red0 = ((uint32_t)read_buffer[3]) << 16;
    uint32_t red1 = ((uint32_t)read_buffer[4]) << 8;
    uint32_t red2 = ((uint32_t)read_buffer[5]);
    uint32_t red_final = (uint32_t)(red0 | red1 | red2) / 10;

    uint16_t hr = (uint16_t(read_buffer[14]) << 8);
    hr |= (read_buffer[15]);
    // hr /= 10;

    uint16_t spo2 = uint16_t(read_buffer[18]) << 8;
    spo2 |= read_buffer[19];
    // spo2 /= 10;

    uint16_t r_value = uint16_t(read_buffer[20]) << 8;
    r_value |= read_buffer[21];
    // r_value /= 1000;

    uint16_t ibi_value = uint16_t(read_buffer[23]) << 8;
    ibi_value |= read_buffer[24];

    // Assign these values to the MAX32664_Data object
    sample.ir = ir_final;
    sample.red = red_final;
    sample.bp_status = read_buffer[12];
    sample.progress = read_buffer[13];
    sample.hr = hr / 10;
    sample.sys_bp = read_buffer[16];
    sample.dia_bp = read_buffer[17];
    sample.spo2 = spo2 / 10;
    sample.r_value = r_value / 1000;
    sample.pulse_flag = read_buffer[22];
    sample.ibi = ibi_value;
    sample.spo2_conf = read_buffer[25];
    sample.bpt_report = read_buffer[26];
    sample.spo2_report = read_buffer[28];
    // Return the result of the read operation
    return read_status;
}

uint8_t ReWire_MAX32664::ConfigureBPT_SensorAndAlgorithm()
{
    // In this function, we are following the steps outlined in Table 8 (section 3.2) of
    //   the document "measuring-heart-rate-and-spo2-using-the-max32664a.pdf".

    // Step 1.1: Load 824 bytes of BPT calibration vector data
    uint8_t status_byte = 255;
    for (uint8_t i = 0; i < 5; ++i)
    {
        status_byte = setCalibrationIndex(i);
        if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
        {
            return status_byte;
        }
        // uint8_t buffer[CalibVectorSize];
        // std::copy(calibVector, calibVector + CalibVectorSize, buffer);

        status_byte = loadBPTCalibVector(calibVector[i], CALIBVECTOR_SIZE);
        if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
        {
            return status_byte;
        }
        delay(30);
    }
    // Step 1.2: THIS STEP IS NOT NEEDED IN FW VER. 40.2.2 AND LATER.
    // Step 1.3: THIS STEP IS NOT NEEDED IN FW VER. 40.2.2 AND LATER.

    // Step 1.4: Set data and time as two 32-bit numbers for
    // YYMMDD and HHMMSS in little-endian format.
    // Provided example is for date:180828, time:163808.
    // status_byte = setDataTime();
    // if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    // {
    //    return status_byte;
    // }
    // delay(10);
    // Step 1.5: Set SpO_2 calibration coefficients as described in
    // the document. Provided example for:
    // A = 1.5958422, B = -34.659664, C = 112.68987
    status_byte = loadSpo2Coefficients(1.5958422, -34.659664, 112.68987); //@note Default values from documentation (change)
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    delay(10);

    // Step 1.7: Ä…Set output mode to sensor + algorithm data
    //(streamed data will include PPG and algorithm data).
    status_byte = SetOutputMode_OutputFormat(MAX32664_OutputModeFormat::SensorData_And_AlgorithmData);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.8: Set sensor hub interrupt threshold to 0x0F (the value used in the datasheet example).
    status_byte = SetOutputMode_FifoInterruptThreshold(0x0F);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.9: Enable the AGC (automatic gain control)
    status_byte = SetAlgorithmMode_EnableAGC(true);
    delay(20);
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.10: Enable the AFE ("analog front end" - the MAX30101 in this case)
    status_byte = EnableSensor(true);
    delay(40);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.11: Enable the BPT Estimation algorithm.
    status_byte = EnableBPT_Algorithm(0x02);
    if (status_byte == MAX32664_ReadStatusByteValue::ERR_TRY_AGAIN)
    {
        do
        {
            delay(10);
            status_byte = EnableBPT_Algorithm(0x02);
        } while (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS);
    }
    else if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    delay(100);

    // Return the result of the final operation
    return status_byte;
}

uint8_t ReWire_MAX32664::ConfigureBPT_RawValue()
{
    // In this function, we are following the steps outlined in Table 8 (section 3.2) of
    //   the document "measuring-heart-rate-and-spo2-using-the-max32664a.pdf".

    // Step 1.7: Set output mode to sensor + algorithm data
    //(streamed data will include PPG and algorithm data).
    uint8_t status_byte = SetOutputMode_OutputFormat(MAX32664_OutputModeFormat::SensorData);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.8: Set sensor hub interrupt threshold to 0x0F (the value used in the datasheet example).
    status_byte = SetOutputMode_FifoInterruptThreshold(0x0F);
    delay(10);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.10: Enable the AFE ("analog front end" - the MAX30101 in this case)
    status_byte = EnableSensor(true);
    delay(1);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.11: Enable the BPT Estimation algorithm.
    status_byte = EnableBPT_Algorithm(0x02);

    if (status_byte == MAX32664_ReadStatusByteValue::ERR_TRY_AGAIN)
    {
        do
        {
            delay(10);
            status_byte = EnableBPT_Algorithm(0x02);
        } while (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS);
    }
    else if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    // Step 1.9: Enable the AGC (automatic gain control)
    status_byte = SetAlgorithmMode_EnableAGC(false);

    // Check to make sure the operation was successful
    if (status_byte == MAX32664_ReadStatusByteValue::ERR_TRY_AGAIN)
    {
        do
        {
            delay(10);
            status_byte = SetAlgorithmMode_EnableAGC(false);
        } while (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS);
    }
    else if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.11: Enable the HR/SpO2 algorithm.
    status_byte = EnableBPT_Algorithm(0x02);
    delay(600);

    // Return the result of the final operation
    return status_byte;
}

uint8_t ReWire_MAX32664::ReadSample_BPTSensor(MAX32664_Data_VerD &sample)
{
    uint8_t read_length = 12;
    uint8_t read_buffer[12] = {0};

    // Read the sample
    uint8_t read_status = ReadOutputFifo(read_buffer, read_length);

    // Parse the sample
    uint32_t ir0 = ((uint32_t)read_buffer[0]) << 16;
    uint32_t ir1 = ((uint32_t)read_buffer[1]) << 8;
    uint32_t ir2 = ((uint32_t)read_buffer[2]);
    uint32_t ir_final = (uint32_t)(ir0 | ir1 | ir2) / 10;

    uint32_t red0 = ((uint32_t)read_buffer[3]) << 16;
    uint32_t red1 = ((uint32_t)read_buffer[4]) << 8;
    uint32_t red2 = ((uint32_t)read_buffer[5]);
    uint32_t red_final = (uint32_t)(red0 | red1 | red2) / 10;

    // Assign these values to the MAX32664_Data object
    sample.ir = ir_final;
    sample.red = red_final;
    sample.bp_status = 0;
    sample.progress = 0;
    sample.hr = 0;
    sample.sys_bp = 0;
    sample.dia_bp = 0;
    sample.spo2 = 0;
    sample.r_value = 0;
    sample.pulse_flag = 0;
    // Return the result of the read operation
    return read_status;
}

uint8_t ReWire_MAX32664::getMCUType(uint8_t &return_byte)
{

    uint8_t status_byte = read_byte(0xFF, 0x00, return_byte);
    return status_byte;
}

uint8_t ReWire_MAX32664::readBPTAlgoCalibData(uint8_t *calibArray)
{

    uint8_t status = read_multiple_bytes(0x51, 0x04, 0x03, calibArray, CALIBVECTOR_SIZE);
    return status;
}

uint8_t ReWire_MAX32664::read_multiple_bytes(uint8_t data1, uint8_t data2, uint8_t data3, uint8_t *read_buffer, uint16_t read_length)
{
    uint8_t status_byte;

    wire_instance->beginTransmission(max32664_i2c_address);
    wire_instance->write(data1);
    wire_instance->write(data2);
    wire_instance->write(data3);
    wire_instance->endTransmission();
    delay(MAX32664_COMMAND_DELAY);

    wire_instance->requestFrom(max32664_i2c_address, read_length + 1, 0, 0, true);
    status_byte = wire_instance->read();
    for (uint16_t i = 0; i < read_length; ++i)
    {
        read_buffer[i] = wire_instance->read();
    }

    return status_byte;
}

uint8_t ReWire_MAX32664::Configure_BPTCalibrationMode()
{
    uint8_t status_byte = setDataTime();
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    status_byte = SetOutputMode_OutputFormat(MAX32664_OutputModeFormat::SensorData_And_AlgorithmData);
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    status_byte = SetOutputMode_FifoInterruptThreshold(0x0F);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    status_byte = SetAlgorithmMode_EnableAGC(true);

    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    // Step 1.10: Enable the AFE ("analog front end" - the MAX30101 in this case)
    status_byte = EnableSensor(true);

    // Check to make sure the operation was successful
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }

    return status_byte;
}
uint8_t ReWire_MAX32664::Start_BPTCalibrationMode(uint8_t calIndex, uint8_t systolicValue, uint8_t dystolicValue)
{
    uint8_t status_byte = setCalibrationIndex(calIndex, systolicValue, dystolicValue);
    if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    delay(10);

    status_byte = EnableBPT_Algorithm(0x01);

    if (status_byte == MAX32664_ReadStatusByteValue::ERR_TRY_AGAIN)
    {
        do
        {
            delay(1);
            status_byte = EnableBPT_Algorithm(0x01);
        } while (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS);
    }
    else if (status_byte != MAX32664_ReadStatusByteValue::SUCCESS_STATUS)
    {
        return status_byte;
    }
    delay(100);
    return status_byte;
}

uint8_t ReWire_MAX32664::setCalibrationIndex(uint8_t calIndex, uint8_t systolicValue, uint8_t dystolicValue)
{
    uint8_t buffer[3] = {calIndex, systolicValue, dystolicValue};
    return write_multiple_bytes(0x50, 0x04, 0x07, buffer, 3, 5);
}
uint8_t ReWire_MAX32664::setCalibrationIndex(uint8_t calIndex)
{
    uint8_t buffer[1] = {calIndex};
    return write_multiple_bytes(0x50, 0x04, 0x08, buffer, 1, 5);
}